#!/usr/bin/env python

"""
    polyA_clipper
    ~~~~~~~~~~~~~
    Given a fastq file (originally one generated by PAT-seq; Poly(A)-Test
    RNA-sequencing), clip poly(A) tails off to allow mapping to genome.

    Performs the following steps:
        1. Loads input fastq file one line at a time;
        2. After loading each group of 4 lines:
            . If the read ends in "AAAAA":
                Clips all "A"s from the end of the sequence
                Updates seq length in lines 0 and 2
                Clip corresponding quality score characters
        3. Appends 4 lines to output file.

    This is a quick first pass that might be enough for our purposes. It is an
    oversimplification, though. The analysis in the paper is more sophisticated.
    It also:
        . Finds runs of “A”s extending into the adaptor sequence
        . Allows an error rate of one base in five
        . Ignores read bases with quality below 10

    :copyright: (c) 2017 by Luis Vale Silva.
    :license: MIT, see LICENSE for more details.
"""

__author__ = "Luis Vale Silva"
__status__ = "Development"

import sys
import os
import time
from colorama import Fore, Back, Style, init as colinit
colinit(autoreset=True)

def main(fastq):
    t0 = time.time()
    print_header()
    
    # Create output file
    output_file = fastq.split('.fastq')[0] + '_A-clipped.fastq'
    if os.path.isfile(output_file):
        sys.exit(Fore.RED + 'ERROR: output file already exists!\n' +
                 Style.RESET_ALL + '\n' +
                 Style.BRIGHT + '-----------------------------------')
    
    open(output_file, 'a').close()

    print('Created output file: ' + output_file)
    print('Clipping poly(A) tails')

    # Read fastq file one line at a time
    read_count = 0
    with open(fastq, 'r') as f:
        read = []
        for line in f:
            read.append(line.rstrip())
            # Read is complete with 4 lines
            if len(read) == 4:
                read_count += 1
                if read_count % 2E+6 == 0:
                    print('... {} reads'.format(read_count))
                # If there's a poly(A) tail, clip it off
                if read[1].endswith('AAAAA'):
                    read = clip_polyA(read)

                # Append to output file
                append_to_output(read, output_file)
                
                # Reset list for new read
                read = []
    
    print() 
    print(Fore.CYAN + 'Clipped {} reads in {}'.format(read_count,
                                                          elapsed_time(t0)) +
          Style.RESET_ALL)
    print(Style.BRIGHT + '-----------------------------------')


def elapsed_time(t0):
    """Given a start time (time.time() object), computes and returns elapsed
    time as a string.
    
    Keyword arguments
    =================
    :param t0: output of time.time()
        Start time to compute elapsed time from (no default)
    :return: str
        Elapsed time.
    """
    t = time.time() - t0
    if t < 60:
        t = "{:2.1f} sec.".format(t)
    elif 60 < t < 3600:
        t = "{:2.1f} min.".format(t / 60)
    else:
        t = "{:2.1f} hr.".format(t / 3600)
    
    return t

def print_header():
    print(Style.BRIGHT + '-----------------------------------')
    print(Style.BRIGHT + '          POLY(A) CLIPPER')
    print(Style.BRIGHT + '-----------------------------------')
    print()

def clip_polyA(read):
    """Clips poly(A) tail from read (and equivalent length from quality string).

    Keyword arguments
    =================
    :param read: list
            List of the four strings of one fastq read (no default)
    :return: list
            Input list after clipping poly(A) tail from read.
    """
    # Clip off poly(A)
    read[1] = read[1].rstrip('A')
    new_length = len(read[1])
    # Update length
    read[0] = read[0].split('length=')[0] + 'length={}'.format(new_length)
    read[2] = read[2].split('length=')[0] + 'length={}'.format(new_length)
    # Clip quality string
    read[3] = read[3][:new_length] 
    
    return read

def append_to_output(read, output_file):
    """Appends read to output file.

    Keyword arguments
    =================
    :param read: list
            List of the four strings of one fastq read (no default)
    :param output_file: str
            Name of file to append new lines to (no default)
    :return: appended file
            Output file with additional four lines of read appended.
    """
    with open(output_file, "a") as f:
        for line in read:
            f.write(line + '\n')


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description="Clip off poly(A) tails.")
    parser.add_argument('-f', '--fastq',
                        help=('path to input fastq input file'), required=True)
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s 0.1')

    # Also print help if no arguments are provided
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    main(args.fastq)
